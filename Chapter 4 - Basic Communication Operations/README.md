# 四、基本的通信操作

在大多数并行算法中，进程需要与其他进程交换数据。这种数据交换会在并行程序的执行过程中引入交互延迟，从而严重影响并行程序的效率。举例来说，回顾第 2.5 节，在带直通路由的互连网络的不同节点上运行的两个进程之间，简单交换一条 $m$ 字信息大约需要 $t_s+mt_w$ 时间。这里，$t_s$ 是数据传输的延迟或启动时间，$t_w$​ 是每个字的传输时间，与节点间的可用带宽成反比。在实际并行程序中，许多交互以明确定义的模式发生，涉及两个以上的进程。通常情况下，要么所有进程一起参与单个全局交互操作，要么进程子集参与每个子集的局部交互。这些常见的进程间交互或通信基本模式经常被用作各种并行算法的构件。在各种并行体系结构上正确实施这些基本通信操作是高效执行使用它们的并行算法的关键。

在本章中，我们将介绍在线性阵列、二维网格和超立方体等简单互连网络上实现一些常用通信模式的算法。选择这些互连网络主要是出于教学方面的考虑。例如，虽然大规模并行计算机不太可能基于线性阵列或环形拓扑结构，但理解线性阵列中的各种通信操作非常重要，因为网格的行和列就是线性阵列。在网格上执行按行或按列通信的并行算法使用的是线性数组算法。网格上一些通信操作的算法是相应线性数组算法在二维上的简单扩展。此外，使用常规数据结构（如数组）的并行算法通常会自然地映射到一维或二维进程数组上。这也使得研究线性阵列或网格互连网络上的进程间交互变得非常重要。另一方面，超立方体架构也很有趣，因为许多具有递归交互模式的算法会自然映射到超立方体拓扑结构上。这些算法中的大多数可能在超立方体以外的互连网络上同样运行良好，但在超立方体上可视化其通信模式更为简单。

本章所介绍的简单网络拓扑结构算法非常实用，非常适合现代并行计算机，尽管大多数现代并行计算机的互连网络不可能与本章所考虑的网络完全匹配。原因在于，在现代并行计算机上，在两个节点之间传输一定大小的数据所需的时间通常与节点在互连网络中的相对位置无关。随机路由算法和直通路由等各种固件和硬件功能可提供这种同质性。此外，终端用户通常无法明确控制将进程映射到物理处理器上。因此，我们假设在互连网络中的任意一对节点之间传输 $m$ 个字的数据会产生 $t_s+mt_w$ 的成本。在大多数架构中，只要源节点和目的节点之间有空闲链路供数据穿越，这一假设就相当准确。但是，如果有多对节点同时通信，那么信息传递的时间可能会更长。如果通过网络横截面的报文数量超过了网络的横截面带宽（第 2.4.4 节），就会出现这种情况。在这种情况下，我们需要调整 $t_w$ 的值，以反映由于拥塞造成的速度减慢。如第 2.5.1 节所述，我们将调整后的 $t_w$ 值称为有效 $t_w$​。当我们遇到可能会导致某些网络拥塞的通信操作时，我们会在文中做出说明。

如第 2.5.2 节所述，在共享地址空间模式中，处理器之间的数据共享成本可使用相同的表达式 $t_s+mt_w$ 来建模，通常 $t_s$ 和 $t_w$​ 的值相对于彼此以及相对于并行计算机处理器的计算速度各不相同。因此，可以认为需要本章讨论的一种或多种交互模式的并行算法会产生成本，其表达式与消息传递的表达式相近。

在接下来的章节中，我们将介绍各种通信操作，并推导出它们的时间复杂度表达式。我们假设互连网络支持直通路由（第 2.5.1 节），并且任何一对节点之间的通信时间实际上与它们之间路径上的中间节点数量无关。我们还假设通信链路是双向的；也就是说，两个直接连接的节点可以在时间 $t_s+mt_w$ 内同时向对方发送大小为 $m$​ 的信息。我们假设采用单端口通信模型，即一个节点每次只能在其一条链路上发送信息。同样，节点每次也只能在一条链路上接收信息。但是，节点可以在接收信息的同时，在同一或不同链路上发送另一条信息。

这里描述的许多操作都有对偶操作和其他相关操作，我们可以使用与原始操作非常相似的程序来执行这些操作。通信操作的**对偶（Dual）**操作与原始操作相反，可以通过颠倒原始操作中信息的方向和顺序来执行。我们将在适用的地方提及此类操作。

## [4.1 One-to-All Broadcast和All-to-One Reduction](./4.1%20One-to-All%20Broadcast%20and%20All-to-One%20Reduction.md)

并行算法通常要求单个进程向所有其他进程或其子集发送相同的数据。这种操作被称为**One-to-All Broadcast**。最初，只有源进程拥有需要广播的大小为 $m$ 的数据。程序结束时，初始数据有 $p$ 份副本，每个进程各一份。One-to-All Broadcast的对偶运算是**All-to-One Reduction**运算。在All-to-One Redection操作中，$p$ 个参与进程中的每个进程都从包含 $m$ 个字的缓冲区 $M$ 开始。来自所有进程的数据通过关联算子合并，并在一个目标进程中累积到一个大小为 $m$ 的缓冲区中。还原法可用于查找一组数字的和、乘积、最大值或最小值 - 累积 $M$ 的第 $i$ 个字是每个原始缓冲区第 $i$​ 个字的和、乘积、最大值或最小值。

- **4.1.1 环型或线性阵列**
- **4.1.2 二维网格**
- **4.1.3 超立方**
- **4.1.4 平衡二叉树**
- **4.1.5 算法细节**
- **4.1.6 开销分析**

## [4.2 All-to-All Broadcast和All-to-All Reduction](./4.2%20All-to-All%20Broadcast%20and%20Reduction.md)

**All-to-All Broadcast**是One-to-All Broadcast的概括，即所有 $p$ 个节点同时发起广播。一个进程向其他每个进程发送相同的 $m$ 字信息，但不同的进程可能广播不同的信息。All-to-All Broadcast用于矩阵运算，包括矩阵乘法和矩阵向量乘法。All-to-All Broadcast的对偶形式是All-to-All Reduction，其中每个节点都是All-to-One Reduction的目的地。

- **4.2.1 环型和线性阵列**
- **4.2.2 二维网格**
- **4.2.3 超立方**
- **4.2.4 开销分析**


## [4.3 All-Reduce和Prefix-Sum操作](./4.3%20All-Reduce%20and%20Prefix-Sum%20Operations.md)

All-to-All Broadcast的通信模式还可用于执行其他一些操作。其中一种操作是还原的第三种变体，即每个节点从大小为 $m$ 的缓冲区开始，操作的最终结果是每个节点上大小为 $m$ 的相同缓冲区，这些缓冲区是通过使用关联算子将原始的 $p$ 个缓冲区组合而成的。从语义上讲，这种操作通常被称为**All Reduce**操作，与执行All-to-One Reduction，然后One-to-All Broadcast结果的操作相同。这种操作不同于All-to-All Reduction，后者是同时进行 $p$​ 个All-to-One Reduction，每个还原结果的目的地都不同。

## [4.4 Scatter和Gather操作](./4.4%20Scatter%20and%20Gather.md)

在**Scatter**操作中，单个节点向其他每个节点发送大小为 $m$ 的唯一信息。这种操作也被称为**One-to-All Personalized Communication**。One-to-All Personalized Communication不同于One-toAll Broadcast，因为源节点一开始会有 $p$ 个唯一的信息，每个节点一个。与One-toAll Broadcast不同，One-to-All Personalized Communication不涉及任何数据重复。One-to-All Personalized Communication或Scatter操作的对偶操作是**Gather**操作或**Concatenation**操作，在这种操作中，单个节点从每个节点收集唯一的信息。收集操作不同于All-to-One Reduce操作，因为它不涉及数据的任何组合或还原。

## [4.5 All-to-All Personalized Communication](./4.5%20All-to-All%20Personalized%20Communication.md)

在**All-to-All Personalized Communication**中，每个节点向其他每个节点发送大小为 $m$ 的不同信息。每个节点向不同的节点发送不同的信息，这与All-to-All Broadcast不同，在All-to-All Broadcast中，每个节点向所有其他节点发送相同的信息。

- **4.5.1 环型**
- **4.5.2 二维网格**
- **4.5.3 超立方**

## [4.6 循环移位](./4.6%20Circular%20Shift.md)

循环移位是更广泛的全局通信操作中的一种，被称为 **置换（Permutation）**。置换是一种同步、一对一的数据再分配操作，其中每个节点向唯一的节点发送一个包含 $m$ 个字的数据包。我们将**循环 $q$ 移位（Circular q-Shift）**定义为在 $p$ 个节点集合$(0<q<p)$中，节点 $i$ 向节点 ${(i + q) \mod p}$ 发送数据包的操作。移位操作适用于某些矩阵计算以及字符串和图像模式匹配。

- **4.6.1 二维网格**
- **4.6.2 超立方**

## [4.7 提高通信速度的方法](./4.7%20Improving%20the%20Speed%20of%20Some%20Communication%20Operations.md)

本章到目前为止，我们已经推导出了各种通信操作的程序及其通信时间，前提是原始信息不能被分割成更小的部分，并且每个节点都有一个用于发送和接收数据的端口。在本节中，我们将简要讨论放宽这些假设对某些通信操作的影响。

- **4.7.1 消息分割与部分路由**
- **4.7.2 全端口通信**

## [4.8 总结](./4.8%20Summary.md)

[表 4.1](#table4.1) 总结了本章讨论的各种集体通信操作的通信时间。One-to-All Broadcast、All-to-One Reduction和All Reduce操作的时间是两个表达式的最小值。这是因为，根据信息大小 $m$ 的不同，第 4.1 和 4.3 节中描述的算法或第 4.7 节中描述的算法速度更快。[表 4.1](#table4.1) 假设选择了最适合给定报文大小的算法。[表 4.1](#table4.1) 中的通信时间表达式是本章前几节在超立方体互连网络的背景下，以直通路由方式推导出来的。不过，这些表达式和相应的算法适用于任何具有 $\Theta(p)$ 截面带宽的架构（第 2.4.4 节）。事实上，[表 4.1](#table4.1) 中列出的所有操作的表达式中，除了全对全个性化通信和循环移位外，与 $t_w$ 相关的术语即使在环网和网状网络（或任何 k-d网状网络）上也保持不变，前提是逻辑进程被适当映射到网络的物理节点上。[表 4.1](#table4.1) 的最后一列给出了在表中第二列给出的时间内执行一项操作所需的渐近截面带宽，假定进程与节点的映射为最佳映射关系。对于大报文，只有All-to-All Personalized Communication 和循环移位需要全部 $\Theta(p)$ 截面带宽。因此，如第 2.5.1 节所述，在横截面带宽较小的网络上应用这些操作的时间表达式时，$t_w$ 项必须反映有效带宽。例如，$p$ 节点方形网格的横截面宽度为 ${\Theta(\sqrt{p})}$，$p$ 节点环形网格的横截面宽度为 $\Theta(1)$。因此，在方形网格上进行全对全个性化通信时，每个字的有效传输时间将是 $\Theta(\sqrt{p})$ 乘以单个链路的 $t_w$，而在环形网络上，则是 $\Theta(p)$ 乘以单个链路的 $t_w$。
